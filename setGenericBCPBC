void Model2D::setGenericBCPBC()
{    
 /** \remark{This IF selects the priority boundary conditions to be set on the
  * phyBounds vector. Note that only these names will be written on top
  * of the others. For instance if a corner point has 2 types of
  * boundary condition, the phyNames below will be written.}
  * 
  * \attention{ PBC has priority over all the conditions already declared, 
  * namely:
  * 
  * - slip walls    : 3rd priority
  * - inflow walls  : 2nd priority
  * - no-slip walls : 1st priority
  *
  * For this reason, any corner point will be set with periodic condition
  * and the new ordering is:
  *
  * - periodic walls : 4th priority
  * - slip walls     : 3rd priority
  * - inflow walls   : 2nd priority
  * - no-slip walls  : 1st priority }
  *
  **/ 

  /* This algorithm sets up physical groups of periodic boundary
  * conditions for a unique pair of master/slave boundaries defined as
  * 
  * "wallLeft"  and   "wallRight" 
  *
  * at ".geo" file. 
  *
  */

 // setGenericBC(), instead setGenericBC(vref) is called after the mesh
 // treatment in the version 'fixed' of mainMovingFrame, requiring
 // update of BC vectors.  
 clearBC();
 
 for( int i=0; i < lineMesh.numElems; i++ )
 {
  int v1 = lineMesh.IEN.Get(i,0);
  int v2 = lineMesh.IEN.Get(i,1);
  int id = lineMesh.idRegion.Get(i);

  // 3rd. priority
  if( lineMesh.phyNames.at(id).compare(5,7,"NormalU") == 0 || 
      lineMesh.phyNames.at(id).compare(5,7,"NormalV") == 0 )
  {
   string aux = lineMesh.phyNames.at(id);
   lineMesh.phyBounds.at(v1) = aux;
   lineMesh.phyBounds.at(v2) = aux;
  }
 }
 
 for( int i=0; i < lineMesh.numElems; i++ )
 {
  int v1 = lineMesh.IEN.Get(i,0);
  int v2 = lineMesh.IEN.Get(i,1);
  int id = lineMesh.idRegion.Get(i);

  // 2nd. priority
  if( lineMesh.phyNames.at(id).compare(5,7,"InflowU") == 0 || 
      lineMesh.phyNames.at(id).compare(5,7,"InflowV") == 0 || 
      lineMesh.phyNames.at(id).compare(5,16,"InflowUParabolic") == 0 || 
      lineMesh.phyNames.at(id).compare(5,16,"InflowVParabolic") == 0 )
  {
   string aux = lineMesh.phyNames.at(id);
   lineMesh.phyBounds.at(v1) = aux;
   lineMesh.phyBounds.at(v2) = aux;
  }
 }

 for( int i=0; i < lineMesh.numElems; i++ )
 {
  int v1 = lineMesh.IEN.Get(i,0);
  int v2 = lineMesh.IEN.Get(i,1);
  int id = lineMesh.idRegion.Get(i);
  
  // 1st. priority
  if( lineMesh.phyNames.at(id).compare(5,6,"NoSlip") == 0 || 
      lineMesh.phyNames.at(id).compare(5,6,"NoSlipConcentration") == 0 || 
      lineMesh.phyNames.at(id).compare(5,14,"NoSlipPressure") == 0 || 
      lineMesh.phyNames.at(id).compare(5,4,"InvU") == 0 || 
      lineMesh.phyNames.at(id).compare(5,4,"InvV") == 0 || 
      lineMesh.phyNames.at(id).compare(5,14,"Inflow2Bubbles") == 0 )
  {
   string aux = lineMesh.phyNames.at(id);
   lineMesh.phyBounds.at(v1) = aux;
   lineMesh.phyBounds.at(v2) = aux;
  }
 }

 
 int count = 0;
 double diameterY = Y.Max()-Y.Min();
 for (list<int>::iterator it=boundaryVert.begin(); it!=boundaryVert.end(); ++it)
 {
  // outflow condition
  if( lineMesh.phyBounds.at(*it) == "\"wallOutflow\"" )
  {
   idbcp.AddItem(*it);
   pc.Set(*it,0.0);
  }

  // inflow condition U
  else if( lineMesh.phyBounds.at(*it) == "\"wallInflowU\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);

   uc.Set(*it,1.0);
   vc.Set(*it,0.0);
  }

  // inflow condition U
  else if( lineMesh.phyBounds.at(*it) == "\"wallInflowUParabolic\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);


   double radius = Y.Get(*it);

   // Parabolic profile
   double Umax = 1.0;
   double aux = 1.5*Umax*( 1.0-radius*radius/
	                     ((diameterY/2.0)*(diameterY/2.0)) );

   uc.Set(*it,aux-1.0);
   vc.Set(*it,0.0);
  }
  
  // inflow condition V
  else if( lineMesh.phyBounds.at(*it) == "\"wallInflowV\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);

   uc.Set(*it,0.0);
   vc.Set(*it,1.0);
  }

  // 2 bubbles inflow condition
  else if( lineMesh.phyBounds.at(*it) == "\"wallInflow2Bubbles\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);

   double aux = X.Get(*it);
   uc.Set(*it,aux);
   aux = (-1.0)*Y.Get(*it);
   vc.Set(*it,aux);
  }

  // moving boundary condition as inflow set to Zero
  else if( lineMesh.phyBounds.at(*it) == "\"wallInflowZeroU\"" || 
		   lineMesh.phyBounds.at(*it) == "\"wallInflowZeroV\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);

   uc.Set(*it,0.0);
   vc.Set(*it,0.0);
  }

  // moving boundary U
  else if( lineMesh.phyBounds.at(*it) == "\"wallInvU\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);
    
   idbcu.Display();
   //uc.Set(*it,-1.0); // prescribed mass flow
   uc.Set(*it,0.0); // PBC
   vc.Set(*it,0.0);
  }

  // moving boundary V
  else if( lineMesh.phyBounds.at(*it) == "\"wallInvV\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);

   uc.Set(*it,0.0);
   vc.Set(*it,-1.0);
  }

  // symmetry boundary U
  else if( lineMesh.phyBounds.at(*it) == "\"wallNormalU\"" )
  {
   idbcu.AddItem(*it);
   uc.Set(*it,0.0);
  }

  // symmetry boundary V
  else if( lineMesh.phyBounds.at(*it) == "\"wallNormalV\"" )
  {
   idbcv.AddItem(*it);
   vc.Set(*it,0.0);
  }

  // periodic boundaries. Any Dirichlet condition is set
  else if ( lineMesh.phyBounds.at(*it) == "\"wallLeft\"" ) 
  {
    /* 
    idbcu.AddItem(*it);
    idbcv.AddItem(*it);
	uc.Set(*it,0.0);
	vc.Set(*it,0.0);
	*/
    //idbcp.AddItem(*it);
	//pc.Set(*it,0.0);
  }
  else if ( lineMesh.phyBounds.at(*it) == "\"wallRight\"" ) 
  {
    /*
    idbcu.AddItem(*it);
    idbcv.AddItem(*it);
	uc.Set(*it,0.0);
	vc.Set(*it,0.0);
    */
    //idbcp.AddItem(*it);
	//pc.Set(*it,0.0);
  }

  // NoSlip with Concentration b.c.
  else if( lineMesh.phyBounds.at(*it) == "\"wallNoSlipConcentration\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);
   idbcc.AddItem(*it);
  
   uc.Set(*it,0.0);
   vc.Set(*it,0.0);
   cc.Set(*it,1.0);
  }

  else if( lineMesh.phyBounds.at(*it) == "\"wallNoSlipPressure\"" )
  {
   if( X.Get(*it) == X.Max() && 
	   Y.Get(*it) == Y.Min() && 
	   count < 1 )
   {
	idbcp.AddItem(*it);

	pc.Set(*it,0.0);
   }
   else
   {
	idbcu.AddItem(*it);
	idbcv.AddItem(*it);

	uc.Set(*it,-1.0);
	vc.Set(*it,0.0);
   }
  }
  // no slip condition if any other is imposed
  else if( lineMesh.phyBounds.at(*it) == "\"wallNoSlip\"" )
  {
   idbcu.AddItem(*it);
   idbcv.AddItem(*it);

   uc.Set(*it,0.0);
   vc.Set(*it,0.0);
  }

 }
}

